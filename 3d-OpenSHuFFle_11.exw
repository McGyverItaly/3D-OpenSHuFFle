-- ============================ 3d-OpenSHuFFle_1.1.exw ============================
-- Read DOCUMENTATION.TXT, or start the program and go to <?>, <Info>

-- SHuFFle is a program that converts a ".shuf" object descriptor into an OpenSCAD ".scad" file.
-- Copyright (C) 2020 Claudio Emiliozzi, Italy
--+------------------------------------------------------------------------------------------------------------------------------+
--¦This program (and correlated file formats) is free software: you can redistribute it and/or modify it under the terms of the  ¦
--¦GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) ¦
--¦any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the ¦
--¦implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.¦
--¦You should have received a copy of the GNU General Public License along with this program.  If not, see                       ¦
--¦<https://www.gnu.org/licenses/>.                                                                                              ¦
--+------------------------------------------------------------------------------------------------------------------------------+

--TAB SIZE = 4

--+-----------------------------------+	   Y=1
--¦		   GUI_SELECTION_AREA		  ¦
--¦									  ¦
--+-----------------------------------+	   GUI_INPUT_END_Y
--¦									  ¦
--¦		   GUI_OPERATING_AREA		  ¦
--¦									  ¦
--¦									  ¦
--¦									  ¦
--¦									  ¦
--¦									  ¦
--¦									  ¦
--+-----------------------------------+



--with trace
without warning
-- GUI constants:
constant BUTW = 50, BUTH = 26 -- BUTW: BUTton Width
constant GUI_INPUT_END_Y = 4*BUTH, LIST1_W = 34

-- Smart Support Array constants:
constant XSTEP = 20, YSTEP = 20, MAX_M = 20, MAX_N = 20
constant N_DOUBLINGS = 3	--how much times the number of section points are doubled

include utils.e
include misc.e
include file.e
include get.e
include graphics.e
include Win32lib.ew


global atom position, file, exist_rotfile, len2_
global sequence fileName, input_file, rot_file, content, hull_data, rot_data, cor_data
--	cor_data is for "center-of-rotation_data"
global sequence section, stl_out, trans, rot, OShull
object temp

fileName="3d-OpenSHuFFle"
input_file = ""
hull_data = ""
rot_file = ""
len2_ = 0

-- David Cuny's Win32 Euphoria wrapper
--==========================================================================--
--							object declarations							--
--==========================================================================--
		constant theWin=  create(Window, fileName & "                   -----==<SHELL-HULL FILE FORMAT to OpenSCAD Objects CoNvErTeR>==-----", 0, 0, 0, 880, 560,  0)
		setWindowBackColor(theWin, rgb(194,164,228))
		setIcon(theWin, IDI_APPLICATION)

	  global constant BMake_shell = create( PushButton,	  		-- the class
							  "SHuFFle to Empty Polyhedron",						-- the caption
							  theWin,						-- the parent
							  BUTW*5, GUI_INPUT_END_Y,				-- x and y position
							  3*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant BMake_shell_text = create( LText,	  	-- the class
							  " -> selected output *_EP.scad file",	-- the caption
							  theWin,						-- the parent
							  BUTW*8, GUI_INPUT_END_Y+8,				-- x and y position
							  10*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags

	  global constant BSave = create( PushButton,	  		-- the class
							  "Save Absolute SHuFFle",			-- the caption
							  theWin,						-- the parent
							  BUTW*5, GUI_INPUT_END_Y+2*BUTH,				-- x and y position
							  3*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant BSave_text = create( LText,	  		-- the class
							  " -> selected output *_ABS.shuf file",	-- the caption
							  theWin,						-- the parent
							  BUTW*8, GUI_INPUT_END_Y+2*BUTH+8,				-- x and y position
							  10*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags

	  global constant BMake_solid = create( PushButton,	-- the class
							  "SHuFFle to Solid Hull",		-- the caption
							  theWin,						-- the parent
							  BUTW*5, GUI_INPUT_END_Y+4*BUTH,				-- x and y position
							  3*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant BMake_solid_text = create( LText,	  	-- the class
							  " -> selected output *.scad file (only for convex boundary shuf slices)",	-- the caption
							  theWin,						-- the parent
							  BUTW*8, GUI_INPUT_END_Y+4*BUTH+8,				-- x and y position
							  10*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags

--		global constant BPrSection = create( PushButton,	-- the class
--							  "List hull_data as Eu.object",-- the caption
--							  theWin,						-- the parent
--							  BUTW*5, GUI_INPUT_END_Y+6*BUTH,				-- x and y position
--							  3*BUTW, BUTH,					-- height and width
--							  0 )							-- no special flags

--		global constant BPrSection_text = create( LText,	-- the class
--							  " -> standard output",			-- the caption
--							  theWin,						-- the parent
--							  BUTW*8, GUI_INPUT_END_Y+6*BUTH+8,				-- x and y position
--							  3*BUTW, BUTH,					-- height and width
--							  0 )							-- no special flags

		global constant BCreateSupportArray = create( PushButton,-- the class
							  "SHuFFle to Support Array",		-- the caption
							  theWin,						-- the parent
							  BUTW*5,GUI_INPUT_END_Y+8*BUTH,				-- x and y position
							  3*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

		global constant BCreateSupportArray_text = create( LText,-- the class
							  " -> selected output *_SA.scad file === EXPERIMENTAL === empty() polyhedron generated",		-- the caption
							  theWin,						-- the parent
							  BUTW*8, GUI_INPUT_END_Y+8*BUTH+8,			-- x and y position
							  9*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

		global constant BRotFile = create( ToggleButton,-- the class
							  "RotFile Off",		-- the caption
							  theWin,						-- the parent
							  BUTW*6.5,GUI_INPUT_END_Y+10*BUTH,				-- x and y position
							  1.5*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

		global constant BRotFile_text = create( LText,-- the class
							  " use/don't use Rotation File",		-- the caption
							  theWin,						-- the parent
							  BUTW*8, GUI_INPUT_END_Y+10*BUTH+8,			-- x and y position
							  9*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags



		global constant Hint_text = create( LText,-- the class
							  "Welcome in \"" & fileName & "\", a code from Claudio Emiliozzi, Italy, written in Euphoria 3.1.1",		-- the caption
							  theWin,						-- the parent
							  BUTW*5, GUI_INPUT_END_Y+13*BUTH+8,			-- x and y position
							  11*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

		global constant List1 = create( List, "", theWin, 10, GUI_INPUT_END_Y, 230, 390, 0 )







--=====================================================================================

	  global constant BINPUT = create( PushButton,	  		-- the class
							  "Input file",					-- the caption
							  theWin,						-- the parent
							  BUTW*0, BUTH*0,				-- x and y position
							  2*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant INPUTtext = create( LText,	  		-- the class
							  "",							-- the caption
							  theWin,						-- the parent
							  BUTW*2, BUTH*0+8,				-- x and y position
							  14*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags

	  global constant OUTPUTLabel = create( CText,	  		-- the class
							  "Output file",				-- the caption
							  theWin,						-- the parent
							  BUTW*0, BUTH*1+8,				-- x and y position
							  2*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant OUTPUTtext = create( EditText,  		-- the class
							  "",							-- the caption
							  theWin,						-- the parent
							  BUTW*2, BUTH*1,				-- x and y position
							  14*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags

	  global constant BrotINPUT = create( PushButton,	  		-- the class
							  "Rot. Input file",					-- the caption
							  theWin,						-- the parent
							  BUTW*0, BUTH*2,				-- x and y position
							  2*BUTW, BUTH,					-- height and width
							  0 )							-- no special flags

	  global constant rotINPUTtext = create( LText,	  		-- the class
							  "",							-- the caption
							  theWin,						-- the parent
							  BUTW*2, BUTH*2+8,				-- x and y position
							  14*BUTW, BUTH,				-- height and width
							  0 )							-- no special flags
--=====================================================================================
-- Menu
constant	MInfo	  	=	create( Menu, 	"&?",theWin, 0,0,0,0,0 ),
			MAbout   		=	create( MenuItem, 	"About", MInfo, 0,0,0,0,0 ),
			MInfo_   		=	create( MenuItem, 	"Info", MInfo, 0,0,0,0,0 )
--			MNew_Prj   	=	create( MenuItem, 	"&New Prj", MFile, 0,0,0,0,0 ),
--			MOpen_Prj	=  	create( MenuItem, 	"&Open Prj", MFile, 0,0,0,0,0 ),
--			MSave_As	=  	create( MenuItem, 	"&Save Prj as", MFile, 0,0,0,0,0 ),
--			Test 		=	create( MenuItem, 	"Test", MFile, 0,0,0,0,0 )
--=====================================================================================

-- translation and rotation: rotation will be executed first, then rotation, with no regard of their position in the input ".shuf" file

global procedure trans_input()	-- move shell/hull by the "a" vector
	sequence arg, a

	a = {0,0,0}
	addItem( List1, "Translate by vector:")
	puts(1, "\n\n")

	for z = 1 to 3 do
		arg = get_argument_now(position, content)
--			puts(1, "_" & arg[1])
		temp = value(arg[1])
		if temp[1] = GET_SUCCESS then
			a[z] = temp[2]
--			puts(1, sprintf("trans[%d] = %f, ", {z, a[z]}))
		else
			--abort(1)
			puts(1, "\n>>>>>>>>>>>> Error in trans_input! <<<<<<<<<<<<\n")
			trans = {0,0,0}
			return
		end if
		position = arg[2]
	end for
	addItem( List1, sprintf("%3.2f, %3.2f, %3.2f", a))
	trans = a
end procedure

global procedure rot_input()	-- perform a shell/hull rotation by the "a" vector, where a[1] is the amount along x axis, and so on
	sequence arg, a

	a = {0,0,0}
	addItem( List1, "Rotate by vector:")
	puts(1, "\n\n")

	for z = 1 to 3 do
		arg = get_argument_now(position, content)
--			puts(1, "_" & arg[1] & "_")
		temp = value(arg[1])
		if temp[1] = GET_SUCCESS then
			a[z] = temp[2]
--			puts(1, sprintf("rot[%d] = %f, ", {z, a[z]}))
		else
			--abort(1)
			puts(1, "\n>>>>>>>>>>>> Error in rot_input! <<<<<<<<<<<<\n")
			rot = {0,0,0}
			return
		end if
		position = arg[2]
	end for
	addItem( List1, sprintf("%3.2f, %3.2f, %3.2f", a))
	rot = a
end procedure

global function file_input()
	sequence arg, a, aa, cirpos, airpos
	sequence xyzmul, airfoil_ch_p, d_, theta_, yc, yt, middle
	atom x, x1, x2, x3, m, p, t, chord, points, theta12, theta23

	position = 0
	position = sfind_end("#translate", content)
	if position != 0 then
		trans_input()
	else
		trans = {0,0,0}
	end if
	position = 0
	position = sfind_end("#rotate", content)
	if position != 0 then
		rot_input()
	else
		rot = {0,0,0}
	end if
	position = 0
	position = sfind_end("#start", content)
	if position = 0 then
		position = sfind_end("#START", content)
	end if

	if position = 0 then
		puts(1,"\n\n\n>>>>>>>>>>>> ERROR: #start NOT FOUND <<<<<<<<<<<<\n")
		return 0
	else
		puts(1, "\n#start")
	end if


	a = {0,0,0}
	xyzmul = {1,1,1}
	while 1 do
		arg = get_argument_now(position, content)
--		puts(1, "\n_" & arg[1] & "_\n")

		if equal(arg[1], "#end") or equal(arg[1], "#END") then
			hull_data &= {section}
			position = arg[2]
			puts(1, "\n#end")
--			puts(1, sprintf("\n#end----position = %d\n", position))
			exit
		elsif equal(arg[1][1], '#') then
			hull_data &= {section}
			section = ""
			xyzmul = {1,1,1}
			position = arg[2]
			puts(1, "\n" & arg[1])
		elsif equal(arg[1], "+circlexz") or equal(arg[1], "+CIRCLEXZ") then
			for z = 1 to 3 do
				arg = get_argument_now(arg[2], content)
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
--					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in file_input (+circlexz statement)! <<<<<<<<<<<<<\n")
					abort(1)
				end if
			end for
			puts(1, sprintf("\n+circlexz %3.2f, %3.2f, %3.2f, ", a))
			cirpos = a
			for z = 1 to 3 do
				arg = get_argument_now(arg[2], content)
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
--					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in file_input (+circlexz semiaxles)! <<<<<<<<<<<<<\n")
					abort(1)
				end if
			end for
			puts(1, sprintf("  %3.2f, %3.2f, %d", a))
			position = arg[2]
--			puts(1, sprintf("\n#-------circlexz position = %d    ", position))
			section = {}
			for i = 0 to a[3]-1 do
				section &= {{cirpos[1]+a[1]*cos(2*PI/a[3]*i), cirpos[2], cirpos[3]+a[2]*sin(2*PI/a[3]*i)}}
			end for
		elsif equal(arg[1], "+circlexy") or equal(arg[1], "+CIRCLEXY")  then
			for z = 1 to 3 do
				arg = get_argument_now(arg[2], content)
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
--					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in file_input (+circlexy statement)! <<<<<<<<<<<<<\n")
					abort(1)
				end if
			end for
			puts(1, sprintf("\n+circlexy %3.2f, %3.2f, %3.2f, ", a))
			cirpos = a
			for z = 1 to 3 do
				arg = get_argument_now(arg[2], content)
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
--					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in file_input (+circlexy semiaxles)! <<<<<<<<<<<<<\n")
					--abort(1)
				end if
			end for
			puts(1, sprintf("  %3.2f, %3.2f, %d", a))
			position = arg[2]
--			puts(1, sprintf("\n#-------circlexy position = %d    ", position))
			section = {}
			for i = 0 to a[3]-1 do
				section &= {{cirpos[1]+a[1]*cos(2*PI/a[3]*i), cirpos[2]+a[2]*sin(2*PI/a[3]*i), cirpos[3]}}
			end for

		elsif length(arg[1])>=5 and (equal(arg[1][1..5], "+NACA") or equal(arg[1][1..5], "+naca")) then
			airfoil_ch_p = {0.000,0.006,0.018,0.036,0.056,0.076,0.100,0.126,0.152,0.170,0.190,0.215,0.240,0.270,0.310,0.350,0.400,0.460,0.535,0.620,0.705,0.785,0.865,0.938,1.000}
--								1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24
			temp = value(arg[1][6..6])
			if temp[1] = GET_SUCCESS then
				m = temp[2]/100
			end if
			temp = value(arg[1][7..7])
			if temp[1] = GET_SUCCESS then
				p = temp[2]/10
			end if
			temp = value(arg[1][8..9])
			if temp[1] = GET_SUCCESS then
				t = temp[2]/100
			end if
			arg = get_argument_now(arg[2], content)
			temp = value(arg[1])
			if temp[1] = GET_SUCCESS then
				chord = temp[2]
			end if

			for z = 1 to 3 do
				arg = get_argument_now(arg[2], content)
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in file_input (+NACA statement)! <<<<<<<<<<<<<\n")
					abort(1)
				end if
			end for

			arg = get_argument_now(arg[2], content)
			temp = value(arg[1])
			if temp[1] = GET_SUCCESS then
				points = temp[2]
			end if

			puts(1, sprintf("\n+NACA %3.2f, %3.2f, %3.2f, %3.2f, %d", {chord} & a & {points}))
			airpos = a
--			puts(1, sprintf("  %3.2f, %3.2f, %d", a))
			position = arg[2]
--			puts(1, sprintf("\n#-------airfoil position = %d    ", position))
			section = repeat({0,0,0}, points)
			section[points/2 + 1] = {1,0,0}
			yc = repeat(0, points+1)
			yt = yc
			theta_ = repeat(0, points+1)

--			d_ = repeat(0, points)
--			section[1] = {}
			x1 = airfoil_ch_p[1]
			yc[1] = 		m/p/p * (2*p*x1 - x1*x1)
			x2 = airfoil_ch_p[2]
			yc[2] = 		m/p/p * (2*p*x2 - x2*x2)
			yc[points/2+1] = 		0

			for i = 2 to points/2 do
				x3 = airfoil_ch_p[i+1]
				if x3 <= p then
					yc[i+1] = m/p/p * (2*p*x3 - x3*x3)
				else
					yc[i+1] = m/(1-p)/(1-p) * ((1-2*p) + 2*p*x3 - x3*x3)
				end if

				theta12 = arctan((yc[i]-yc[i-1])/(x2-x1))
				theta23 = arctan((yc[i+1]-yc[i])/(x3-x2))
				theta_[i] = (theta12+theta23)/2

				yt[i] = 5 * t *(0.2969*sqrt(x2) - .1260*x2 - .3516*x2*x2 + .2843*x2*x2*x2 - .1015*power(x2,4))
				x1 = x2
				x2 = x3
			end for
--			section[1] = {0,0,0}	superfluo
			section[points/2+1] = chord * {1,0,0}

			for i = 2 to points/2 do			-- Upper surface
				section[i] = 	chord * {airfoil_ch_p[i]          -yt[i]*sin(theta_[i]), 					0, yc[i] + yt[i]*cos(theta_[i])}
			end for
			for i = points/2 + 2 to points do	-- Lower surface
				section[i] = 	chord * {airfoil_ch_p[points-i+1] +yt[points-i+1]*sin(theta_[points-i+1]), 	0, yc[points-i+1] - yt[points-i+1]*cos(theta_[points-i+1])}
			end for

			middle = {0, 0, 0}
			for i = 1 to points do
				middle += section[i]
			end for
			middle /= points
			addItem( List1, sprintf(   "middle_x = %3.2f, middle_z = %3.2f", {middle[1],middle[3]}))
			puts( 1,        sprintf("\n middle_x = %3.2f, middle_z = %3.2f", {middle[1],middle[3]}))
			a -= middle
			aa = repeat(a, points)

			section += aa

		else								-- sparse points section ========================
			for z = 1 to 3 do				-- incremental coord. ========================
				if z != 1 then
					arg = get_argument_now(arg[2], content)
		--			puts(1, "_" & arg[1])
				end if
				if arg[1][1] = '@' then
					temp = value(arg[1][2..length(arg[1])])
					if temp[1] = GET_SUCCESS then
						a[z] = hull_data[length(hull_data)][length(section)+1][z] + temp[2] * xyzmul[z]
--						addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--						puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
					else
						puts(1, "\n>>>>>>>>>>>> Error in file_input (wrong incremental \"@\" data entry <" & arg[1] & ">)! <<<<<<<<<<<<<\n")
						return 0
					end if
				else						-- absolute coord. ========================
					temp = value(arg[1])
					if temp[1] = GET_SUCCESS then
						a[z] = temp[2] * xyzmul[z]
--						addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--						puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
					else
						puts(1, "\n>>>>>>>>>>>> Error in file_input (wrong absolute data entry <" & arg[1] & ">)! <<<<<<<<<<<<<\n")
						return 0
					end if
				end if
			end for
			puts(1, sprintf("\n%3.2f, %3.2f, %3.2f", a))

			position = arg[2]
--			puts(1, sprintf("\n--------position = %d    ", position))

			section &= {a}
		--	print(1,hull_data)
		end if
	end while
	return 1
end function	-- file_input()

global function rotfile_input()
	sequence arg, a, cor
	atom flag

	cor_data = ""
	cor = "CP"	-- "CP" or "FP"
	position = 0
	position = sfind_end("#rotstart", content)
	puts(1,"\n\n#rotstart")
--	puts(1, sprintf("\n#rotstart--position = %d    ", position))
--	addItem( List1, "#rotstart")

	if position = 0 then
		puts(1,"\n\n\n>>>>>> ERROR: #rotstart NOT FOUND <<<<<<\n\n")
		return 0
	end if


--	a = {0,0,0,0,0,0,1,1,1,0,0,0}	-- center of rot. - rotation - (amplif. - move)
	while 1 do
		a = {0,0,0,0,0,0,1,1,1,0,0,0}	-- center of rot. - rotation - (amplif. - move)
		arg = get_argument_now(position, content)
--		puts(1, "\n_" & arg[1] & "_\n")

		if equal(arg[1], "#rotend") then
			rot_data &= {section}
			cor_data &= {cor}
			position = arg[2]
			puts(1, "\n#rotend")
--			puts(1, sprintf("\n#rotend----position = %d\n", position))
--			addItem( List1, "#rotend")
			exit
		elsif equal(arg[1][1], '#') then
			rot_data &= {section}
			cor_data &= {cor}
			section = ""
			position = arg[2]
			puts(1, "\n" & arg[1])
--			puts(1, sprintf("\n#-------position = %d    ", position))
--			addItem( List1, "#")
		elsif equal(arg[1], "CP") or equal(arg[1], "cp") then
			cor = "CP"	-- "CP" or "FP"
			position = arg[2]
		elsif equal(arg[1], "FP") or equal(arg[1], "fp") then
			cor = "FP"	-- "CP" or "FP"
			position = arg[2]
		else
			flag = 0
			for z = 1 to 12 do	-- reading rotfile section arguments
				if z != 1 then	-- for z=1 argument already present in "arg" sequence
					position = arg[2]
					arg = get_argument_now(position, content)
		--			puts(1, "_" & arg[1])
				end if
				if equal(arg[1][1..1], "#") then
					flag = 1	-- shortcut if some arguments are missing
					exit
				end if
				temp = value(arg[1])
				if temp[1] = GET_SUCCESS then
					a[z] = temp[2]
--					addItem( List1, sprintf("a[%d] = %f, ", {z, a[z]}))
--					puts(1, sprintf("a[%d] = %f, ", {z, a[z]}))
				else
					puts(1, "\n>>>>>>>>>>>> Error in  rotfile input! (wrong data entry <" & arg[1] & ">)! <<<<<<<<<<<<<\n")
--					puts(1, "\n>>>>>>>>>>>> Error in  rotfile input! <<<<<<<<<<<<\n")
					return 0
				end if
			end for
			puts(1, sprintf("\ncx%3.2f, cy%3.2f, cz%3.2f,  <%3.2f, <%3.2f, <%3.2f, *%1.1f *%1.1f *%1.1f, M%2.1f_%2.1f_%2.1f", a))
--			addItem( List1, sprintf("%3.1f,%3.1f,%3.1f,%3.1f,%3.1f,%3.1f", a))
--			addItem( List1, sprintf("P=%3.1f,%3.1f,%3.1f", a[1..3]))
--			addItem( List1, sprintf("R=%3.1f,%3.1f,%3.1f", a[4..6]))

			if flag = 0 then
				position = arg[2]
			end if
--			puts(1, sprintf("\n--------position = %d    ", position))

			section = a
		--	print(1,rot_data)
		end if
	end while
	return 1
end function	--rotfile_input()

function translate_(sequence hull_d, sequence trans_)
		atom len1, len2

	len1 = length(hull_d)
	len2 = length(hull_d[1])
-- translate hull_d by trans_ vector
	for i=1 to len1 do
		for j=1 to len2 do
			hull_d[i][j] += trans_
		end for
	end for
	return hull_d
end function

function rotate_(sequence hull_d, sequence rot_)
	atom len1, len2, rx, alfa

	len1 = length(hull_d)
	len2 = length(hull_d[1])

	rot_ = 1/180*PI * rot_

-- rotate x axis by rot[1]
	if rot_[1] != 0 then
		for i=1 to len1 do
			for j=1 to len2 do
				if  hull_d[i][j][2] !=0 then
					rx = sqrt(hull_d[i][j][3]*hull_d[i][j][3]+hull_d[i][j][2]*hull_d[i][j][2])
					alfa = arctan(hull_d[i][j][3]/hull_d[i][j][2])
					if (hull_d[i][j][3] < 0 and hull_d[i][j][2] < 0) or (alfa = 0 and hull_d[i][j][2] < 0) then
						alfa += PI
					elsif (hull_d[i][j][3] > 0 and hull_d[i][j][2] < 0) then
						alfa += PI
					end if
				else
					if hull_d[i][j][3] >= 0 then
						alfa = arctan(0) + PI/2
						rx = hull_d[i][j][3]
					else
						alfa = arctan(0) - PI/2
						rx = - hull_d[i][j][3]
					end if
				end if
				hull_d[i][j][2] = rx*cos(alfa+rot_[1])
				hull_d[i][j][3] = rx*sin(alfa+rot_[1])
			end for
		end for
	end if

-- rotate y axis by rot[2]
	if rot_[2] != 0 then
		for i=1 to len1 do
			for j=1 to len2 do
				if  hull_d[i][j][3] !=0 then
					rx = sqrt(hull_d[i][j][1]*hull_d[i][j][1]+hull_d[i][j][3]*hull_d[i][j][3])
					alfa = arctan(hull_d[i][j][1]/hull_d[i][j][3])
					if (hull_d[i][j][1] < 0 and hull_d[i][j][3] < 0) or (alfa = 0 and hull_d[i][j][3] < 0) then
						alfa += PI
					elsif (hull_d[i][j][1] > 0 and hull_d[i][j][3] < 0) then
						alfa += PI
					end if
				else
					if hull_d[i][j][1] >= 0 then
						alfa = arctan(0) + PI/2
						rx = hull_d[i][j][1]
					else
						alfa = arctan(0) - PI/2
						rx = - hull_d[i][j][1]
					end if
				end if
				hull_d[i][j][3] = rx*cos(alfa+rot_[2])
				hull_d[i][j][1] = rx*sin(alfa+rot_[2])
			end for
		end for
	end if

-- rotate z axis by rot[3]
	if rot_[3] != 0 then
		for i=1 to len1 do
			for j=1 to len2 do
				if  hull_d[i][j][1] !=0 then
					rx = sqrt(hull_d[i][j][2]*hull_d[i][j][2]+hull_d[i][j][1]*hull_d[i][j][1])
					alfa = arctan(hull_d[i][j][2]/hull_d[i][j][1])
					if (hull_d[i][j][2] < 0 and hull_d[i][j][1] < 0) or (alfa = 0 and hull_d[i][j][1] < 0) then
						alfa += PI
					elsif (hull_d[i][j][2] > 0 and hull_d[i][j][1] < 0) then
						alfa += PI
					end if
				else
					if hull_d[i][j][2] >= 0 then
						alfa = arctan(0) + PI/2
						rx = hull_d[i][j][2]
					else
						alfa = arctan(0) - PI/2
						rx = - hull_d[i][j][2]
					end if
				end if
				hull_d[i][j][1] = rx*cos(alfa+rot_[3])
				hull_d[i][j][2] = rx*sin(alfa+rot_[3])
			end for
		end for
	end if
--	hull_data = hull_d
	return hull_d
end function

function apply_rot( sequence hull_d )
	atom len1, len2
	sequence hull_d_, middle, amplify
	hull_d_ = hull_d
	len1 = length(hull_d)
	len2 = length(hull_d[1])
	for i=len1 to 1 by -1 do
		middle = {0,0,0}
		for j = 1 to len2 do
			middle += hull_d[i][j]
		end for
		middle /= len2
		amplify = repeat(rot_data[i][7..9], len2)
		if equal(cor_data[i], "CP") then
			hull_d_[i..len1] = translate_(hull_d[i..len1], -middle-rot_data[i][1..3])
			if i < len1 then
				hull_d_[i..len1] = rotate_({hull_d_[i]*amplify} & hull_d_[i+1..len1], 	rot_data[i][4..6])
			else
				hull_d_[i..len1] = rotate_({hull_d_[i]*amplify}, 						rot_data[i][4..6])
			end if
			hull_d_[i..len1] = translate_(hull_d_[i..len1],	middle+rot_data[i][1..3]+rot_data[i][10..12])
			hull_d = hull_d_
		elsif equal(cor_data[i], "FP") then
			hull_d_[i..len1] = translate_(hull_d[i..len1], -hull_d[i][1]-rot_data[i][1..3])
			if i < len1 then
				hull_d_[i..len1] = rotate_({hull_d_[i]*amplify} & hull_d_[i+1..len1], 	rot_data[i][4..6])
			else
				hull_d_[i..len1] = rotate_({hull_d_[i]*amplify}, 						rot_data[i][4..6])
			end if
--			hull_d_[i..len1] = rotate_(hull_d_[i..len1], 	rot_data[i][4..6])
			hull_d_[i..len1] = translate_(hull_d_[i..len1],	hull_d[i][1]+rot_data[i][1..3]+rot_data[i][10..12])
			hull_d = hull_d_
		else
			puts(1, "\n>>>>>>>>>>>> Error in \"center of rotation\": type unknown! <<<<<<<<<<<<\n")
		end if
	end for
	return hull_d
end function

global function Open_shuf(sequence default)
	sequence fname
	fname = getOpenFileName(theWin, default, {"shuf file (.shuf)", "*.shuf"})
	if not sequence(fname) or equal(fname,"") then
		puts(1, "\n\n>>>>>> Error in filename!!! <<<<<<\n")
		return ""
	end if
	setText(Hint_text, ".shuf input file selected")
	addItem( List1, "Input file selected")
	return fname
end function

global function Open_rot(sequence default)
	sequence fname
	fname = getOpenFileName(theWin, default, {"shuf file (.shuf)", "*.shuf"})
	if not sequence(fname) or equal(fname,"") then
		puts(1, "\n\n>>>>>> Error in filename!!! <<<<<<\n")
		return ""
	end if
	setText(Hint_text, "rotation file selected")
	addItem( List1, "Rotation file selected")
	return fname
end function

global function Load_input_file()
	atom len2
	if not sequence(input_file) or equal(input_file,"") then
		return 0
	else
		file = open(input_file, "r")
	end if
	content = {}
	hull_data = ""
	section = ""

	puts(1,"\n\n\n====== LOADING INPUT FILE ======\n")

	content = load_file(file)

	close(file)
--	print(1,"\n" & content & "\n")
	position = sfind_end("#start", content)
	puts(1, "\n#start")

	if file_input() then
		if equal (hull_data, "") then
			return 0
		end if
	else
		return 0
	end if
	len2_ = length(hull_data[1])
	if length(hull_data) >= 2 and len2_ >= 3 then
		for i = 2 to length(hull_data) do
			len2 = length(hull_data[i])
			if len2 != len2_ then
				setText(Hint_text, ">>>>> WRONG SECTION N. "& sprintf("%d: %d <> %d!\n", {i, len2, len2_}))
				return 0
			end if
		end for
	else
		return 0
	end if

	hull_data = rotate_(hull_data, rot)
	hull_data = translate_(hull_data, trans)
	setText(Hint_text, "Hull loaded")
	return 1
end function

global function Load_rot_file()
	if not sequence(rot_file) or equal(rot_file,"") then
		return 0
	else
		file = open(rot_file, "r")
	end if
	content = {}
	rot_data = {}

	puts(1,"\n\n\n====== LOADING ROTATION INPUT FILE ======\n")

	content = load_file(file)

	close(file)
--	print(1,"\n" & content & "\n")
--	position = sfind_end("#start", content)
--	puts(1, sprintf("\n#start--position = %d    ", position))

	if rotfile_input() then
		if equal (rot_data, "") then
			return 0
		end if
	else
		return 0
	end if
	return 1
end function


global procedure  onClick_BMake_solid()		-- every section boundary must be convex
	atom len1, len2, rotflag
	sequence v1, v2, vn, out_file

	if Load_input_file() = 0 then
		addItem( List1, "ERROR IN LOADING HULL FILE")
		return
	end if
	addItem( List1, "GENERATING SOLID HULL FILE:")

	if isChecked(BRotFile) then
		if Load_rot_file() = 1 then
			rotflag = 1
			addItem( List1, "Rotfile loaded")
		else
			rotflag = 0
			addItem( List1, ">>>>>>> Rotfile not loaded!!!")
		end if
	else
		rotflag = 0
	end if

	out_file = getText(OUTPUTtext)
	file = open(out_file,"w")
	if length(out_file) > LIST1_W then
		addItem( List1, "..." & out_file[length(out_file)-LIST1_W..length(out_file)])
	else
		addItem( List1, out_file)
	end if

	puts(1,"\n\n\n====== SAVING " & out_file & " FILE ======\n")

	len1 = length(hull_data)
	len2 = length(hull_data[1])

	if len1<2 then
		puts(1, "\n\n\n>>>>>>>>>> Error: input file with less than 2 levels! <<<<<<<<<<\n")
		return
	end if

	if rotflag = 1 then
		hull_data = apply_rot(hull_data)
	end if

	OShull = ""	--OpenSCAD polyhedron() transformed in solid object by the hull() statement
	for i=1 to len1-1 do
		puts(file, 	"hull() {polyhedron (\n\tpoints = [")
		OShull &=	"hull() {polyhedron (\n\tpoints = ["
		for j=1 to len2 do
			puts(file, 	sprintf("[%f,%f,%f],", {hull_data[i][j][1], hull_data[i][j][2], hull_data[i][j][3]}))
			OShull &=	sprintf("[%f,%f,%f],", {hull_data[i][j][1], hull_data[i][j][2], hull_data[i][j][3]})
		end for
		for j=1 to len2 do
			if not (j = len2) then
				puts(file, 	sprintf("[%f,%f,%f],", {hull_data[i+1][j][1], hull_data[i+1][j][2], hull_data[i+1][j][3]}))
				OShull &=	sprintf("[%f,%f,%f],", {hull_data[i+1][j][1], hull_data[i+1][j][2], hull_data[i+1][j][3]})
			else
				puts(file,  sprintf("[%f,%f,%f]", {hull_data[i+1][j][1], hull_data[i+1][j][2], hull_data[i+1][j][3]}))
				OShull &=	sprintf("[%f,%f,%f]", {hull_data[i+1][j][1], hull_data[i+1][j][2], hull_data[i+1][j][3]})
			end if
		end for

		puts(file, 	"],\n\tfaces = [")
		OShull &=	"],\n\tfaces = ["
		for j=0 to len2-2 do
			puts(file, 	sprintf("[%d, %d, %d], ", 	{j+1, j, len2+j}))
			OShull &=	sprintf("[%d, %d, %d], ", 	{j+1, j, len2+j})
			puts(file, 	sprintf("[%d, %d, %d], ", 	{j+1, len2+j,   len2+j+1}))
			OShull &=	sprintf("[%d, %d, %d], ", 	{j+1, len2+j,   len2+j+1})
		end for
		puts(file, 		sprintf("[%d, %d, %d], ", 		{0,	 len2-1,   len2*2-1}))
		OShull &=		sprintf("[%d, %d, %d], ", 		{0,	 len2-1,   len2*2-1})
		puts(file, 		sprintf("[%d, %d, %d]", 		{0,	 len2*2-1, len2}))
		OShull &=		sprintf("[%d, %d, %d]", 		{0,	 len2*2-1, len2})
		puts(file, 	"]);\n}\n")
		OShull &=	"]);\n}\n"
	end for
	close(file)
	setText(Hint_text, "Output solid object *.scad file generated")
	addItem( List1, "SOLID HULL GENERATED")

end procedure






global procedure  onClick_BMake_shell()	-- create a multi-face empty structure
	atom len1, len2, rotflag
	sequence Text, out_file
--	sequence v1, v2, vn

	if Load_input_file() = 0 then
		addItem( List1, "ERROR IN LOADING SHELL FILE")
		return
	end if
	addItem( List1, "GENERATING SHELL FILE:")

	if isChecked(BRotFile) then
		if Load_rot_file() = 1 then
			rotflag = 1
			addItem( List1, "Rotfile loaded")
		else
			rotflag = 0
			addItem( List1, ">>>>>>> Rotfile not loaded!!!")
		end if
	else
		rotflag = 0
	end if

	Text = getText(OUTPUTtext)
	out_file = Text[1..length(Text)-5]&"_EP.scad"
	file = open(out_file,"w")
	if length(out_file) > LIST1_W then
		addItem( List1, "..." & out_file[length(out_file)-LIST1_W..length(out_file)])
	else
		addItem( List1, out_file)
	end if

	puts(1,"\n\n\n====== SAVING SHELL (empty polyhedron) " & out_file & " FILE ======\n")

	puts(file, "polyhedron (\n\tpoints = [")

	len1 = length(hull_data)
	len2 = length(hull_data[1])

	if len1<2 then
		puts(1, "\n\n\n>>>>>>>>>>> Error: input file with less than 2 levels! <<<<<<<<<<\n")
		return
	end if
	if rotflag = 1 then
		hull_data = apply_rot(hull_data)
	end if

	for i=1 to len1 do
		for j=1 to len2 do
			if not (i = len1 and j = len2) then
				puts(file, sprintf("[%f,%f,%f],", {hull_data[i][j][1], hull_data[i][j][2], hull_data[i][j][3]}))
			else
				puts(file, sprintf("[%f,%f,%f]", {hull_data[i][j][1], hull_data[i][j][2], hull_data[i][j][3]}))
			end if
		end for
	end for

	puts(file, "],\n\tfaces = [")

--	base1
	for j=2 to len2-1 do
		puts(file, sprintf("[%d,%d,%d],", {0, j-1, j}))
	end for

	puts(file, "\n\n")

--	parallelepipedi/coni intermedi
	for i=1 to len1 - 1 do
		for j=0 to len2-2 do
			puts(file, sprintf("[%d, %d, %d], ", 	{len2*(i-1)+j+1, len2*(i-1)+j, len2*(i)+j}))
			puts(file, sprintf("[%d, %d, %d], ", 	{len2*(i-1)+j+1, len2*(i)+j,   len2*(i)+j+1}))
		end for
		puts(file, sprintf("[%d, %d, %d], ", 		{len2*(i-1),	 len2*(i)-1,   len2*(i+1)-1}))
		puts(file, sprintf("[%d, %d, %d], ", 		{len2*(i-1),	 len2*(i+1)-1, len2*(i)}))
	end for

--	base2
	puts(file, "\n\n")
	for j=2 to len2-2 do
		puts(file, sprintf("[%d,%d,%d],", {(len1-1)*len2, (len1-1)*len2+j, (len1-1)*len2+j-1}))
	end for
	puts(file, sprintf("[%d,%d,%d]", {(len1-1)*len2, len1*len2-1, len1*len2-2}))
	puts(file, "]);")

	close(file)
	setText(Hint_text, "Output Empty Polyhedron *_EP.scad file generated")
	addItem( List1, "SHELL GENERATED")
end procedure





global procedure  onClick_BPrSection()
	puts(1, "\n")
--	print(1,section)
	puts(1, "\n")
	print(1,hull_data)
	setText(Hint_text, "Hull_data printed as Euphoria object on standard output")
end procedure





global procedure  onClick_BSave_ABS_file()	-- save a translated and rotated .shuf file, with
	atom len1, len2, rx, alfa, rotflag		-- absolute coordinates
	sequence Text, out_file

	if Load_input_file() = 0 then
		addItem( List1, "ERROR IN LOADING SHuFFle FILE")
		return
	end if
	addItem( List1, "GENERATING ABSOLUTE SHuFFle FILE:")

	if isChecked(BRotFile) then
		if Load_rot_file() = 1 then
			rotflag = 1
			addItem( List1, "Rotfile loaded")
		else
			rotflag = 0
			addItem( List1, ">>>>>>> Rotfile not loaded!!!")
		end if
	else
		rotflag = 0
	end if

	Text = getText(OUTPUTtext)
	out_file = Text[1..length(Text)-5]&"_ABS.shuf"
	file = open(out_file,"w")
	if length(out_file) > LIST1_W then
		addItem( List1, "..." & out_file[length(out_file)-LIST1_W..length(out_file)])
	else
		addItem( List1, out_file)
	end if

	puts(1,"\n\n\n====== SAVING ABSOLUTE " & out_file & " FILE ======\n")

	puts(file,"#start\n")

	len1 = length(hull_data)
	len2 = length(hull_data[1])

	if len1<2 then
		puts(1, "\n\n\n>>>>>>>>>>> Error: input file with less than 2 levels! <<<<<<<<<<\n")
		return
	end if
	if rotflag = 1 then
		hull_data = apply_rot(hull_data)
	end if


	for i=1 to len1 do
		if i != 1 then
			printf(file, "#%d\n", i)
		end if
		for j=1 to len2 do
			puts(file, sprintf("%3.1f %3.1f %3.1f\n",{hull_data[i][j][1], hull_data[i][j][2], hull_data[i][j][3]}))
		end for
	end for
	puts(file,"#end")
	close(file)
	setText(Hint_text, "Outuput *_ABS.shuf (with absolute coords) file generated")
	addItem( List1, "ABSOLUTE SHuFFle FILE GENERATED")
end procedure




global procedure  onClick_BCreateSupportArray()
	atom len, len1, len2, min_x, max_x, min_y, max_y, min_z, max_z, count_x, count_y, rx, ry, flag
	atom sm, em, sn, en, s_x, s_y, s_z, e_x, e_y, e_z
	sequence sup_z, dummy, out_file, out_text

	if Load_input_file() = 0 then
		addItem( List1, "ERROR IN LOADING HULL FILE")
		return
	end if


	if equal(hull_data,"") then
		puts(1, "\n\n\n>>>>>> NULL hull_data FILE <<<<<<\n")
		return
	end if
	onClick_BMake_solid()
	len1 = length(hull_data)
	len2 = length(hull_data[1])

	if len1<2 then
		puts(1, "\n\n\n>>>>>>>>>>> Error: input file with less than 2 levels! <<<<<<<<<<\n")
		return
	end if
	addItem( List1, "GENERATING SUPPORT ARRAY:")
--	file = open("out_supports.scad","w")
	out_text = getText(OUTPUTtext)
	len = length(out_text)
	out_file = out_text[1..len-5] & "_SA.scad"
	puts(1, "\n_" & out_file & "_")
	file = open(out_file,"w")
	if length(out_file) > LIST1_W then
		addItem( List1, "..." & out_file[length(out_file)-LIST1_W..length(out_file)])
	else
		addItem( List1, out_file)
	end if
	puts(1, "\n\n\n====== Generating " & out_file & " Support Array ======\n")

--	onClick_BMake_solid()

	min_x = hull_data[1][1][1]
	max_x = hull_data[1][1][1]
	min_y = hull_data[1][1][2]
	max_y = hull_data[1][1][2]
	min_z = hull_data[1][1][3]
	max_z = hull_data[1][1][3]


	puts(file, "$fn=10;\nmodule empty(){\n" & OShull)
	puts(file, "\n}\nmodule support(h_){\n\ttranslate([0,0,2*h_])\n\t\tintersection(){\n\t\t\tdifference(){\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([0,0,h_/2]){\n\t\t\t\t\t\tcube([h_, .4, 2*h_], center = true);\n\t\t\t\t\t\tcube([.4, h_, 2*h_], center = true);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([0,h_/5,h_/2])\n\t\t\t\t\t\tcube([h_, .4, 2*h_], center = true);\n\t\t\t\t\ttranslate([0,2*h_/5,h_/2])\n\t\t\t\t\t\tcube([h_, .4, 2*h_], center = true);\n\t\t\t\t\ttranslate([0,-h_/5,h_/2])\n\t\t\t\t\t\tcube([h_, .4, 2*h_], center = true);\n\t\t\t\t\ttranslate([0,-2*h_/5,h_/2])\n\t\t\t\t\t\tcube([h_, .4, 2*h_], center = true);\n\t\t\t\t}\n\t\t\t\t\ttranslate([0,0,0])\n\t\t\t\t\tcylinder(d1=1.7*h_, d2=h_/5, h=3/5*h_);\n\t\t\t}\n\t\t\tcylinder(d1=h_/4,d2=14*h_/5,h=7*h_/5);\n\t\t}\n\tdifference(){\n\t\tcylinder(d=.852*h_,h=5*h_/2);\n\t\ttranslate([0,0,-1])\n\t\t\tcylinder(d=.852*h_-0.8,h=5*h_/2+2);\n\t}\n}\n")

	for i=1 to len1 do		--searching for max & min
		for j=1 to len2 do
			if hull_data[i][j][1] < min_x then min_x = hull_data[i][j][1] end if
			if hull_data[i][j][1] > max_x then max_x = hull_data[i][j][1] end if
			if hull_data[i][j][2] < min_y then min_y = hull_data[i][j][2] end if
			if hull_data[i][j][2] > max_y then max_y = hull_data[i][j][2] end if
			if hull_data[i][j][3] < min_z then min_z = hull_data[i][j][3] end if
			if hull_data[i][j][3] > max_z then max_z = hull_data[i][j][3] end if
		end for
	end for
	for z=1 to N_DOUBLINGS do
		for i=1 to len1 do		--section points multiplier
			dummy = hull_data[i]
			len = length(dummy)
			for j=1 to (len2-1)*2+1 by 2 do
				if j != (len2-1)*2+1 then
					dummy = dummy[1..j] & {{(dummy[j][1]+dummy[j+1][1])/2, (dummy[j][2]+dummy[j+1][2])/2,(dummy[j][3]+dummy[j+1][3])/2}} & dummy[j+1..len]
				else
					dummy = dummy[1..j] & {{(dummy[j][1]+dummy[1][1])/2, (dummy[j][2]+dummy[1][2])/2,(dummy[j][3]+dummy[1][3])/2}}
				end if
--				pretty_print(1, dummy, {})
				len = length(dummy)
			end for
			hull_data[i] = dummy
		end for
		len1 = length(hull_data)
		len2 = length(hull_data[1])
	end for

	count_x = MAX_M			--MAX_M					-- floor((max_x-min_x)/XSTEP)+1
	count_y = MAX_N			--MAX_N					-- floor((max_y-min_y)/YSTEP)+1
	sup_z = repeat(repeat(0, count_x), count_y)


	for n=0 to count_y-1 do
		for m=0 to count_x-1 do
			for i=1 to len1 do
				for j=1 to len2 do
					rx = (hull_data[i][j][1] - min_x)/count_x
					ry = (hull_data[i][j][2] - min_y)/count_y
					if rx >= m and rx < m+1 and ry >= n and ry < n+1 then
						if sup_z[m+1][n+1] != 0 and hull_data[i][j][3] + min_z > sup_z[m+1][n+1] then
							sup_z[m+1][n+1] = hull_data[i][j][3]+min_z
						elsif sup_z[m+1][n+1] = 0 then
							sup_z[m+1][n+1] = hull_data[i][j][3]+min_z
						end if
					end if
				end for
			end for
		end for
	end for



	printf(file,  "\nmax_z=[[%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d],\n", sup_z[1])	-- every row is composed of count_y "%d" symbols
	for i = 2 to count_x-1 do
		printf(file,"       [%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d],\n", sup_z[i])
	end for
	printf(file,    "       [%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d]];", 	sup_z[count_x])


	puts(file,"")
	printf(file, "\nintersection(){\n\trotate([%f,%f,%f])\n\t\ttranslate([%f,%f,%f])\n\t\t\tempty();\n\tfor (i=[0:%d-1]){\n\t\tfor(j=[0:%d-1]){\n\t\t\tif (max_z[i][j]!=0.0){\n\t\t\t\ttranslate([i*20,j*20,max_z[i][j]-60])\n\t\t\t\t\tsupport(20);\n\t\t\t}\n\t\t}\n\t}\n}",{rot[1], rot[2], rot[3], trans[1], trans[2], trans[3], count_x, count_y})

	close(file)
	puts(1, "\n\n\n====== Support Array " & out_file & " file generated ======\n")
	setText(Hint_text, "\n\n====== Support Array " & out_file & " file generated ======")
	addItem( List1, "SUPPORT ARRAY GENERATED")
end procedure	--onClick_BCreateSupportArray()

--procedure onClick_BSave_call()
--	onClick_BSave("input.shuf")
--end procedure

procedure onClick_BINPUT()
--	Load_input_file()
	sequence dummy
	dummy = Open_shuf("")
	if not equal(dummy, "") then
		puts(1,"\ninput_file = " & dummy & "\n")
--		puts(logfile,"dummy = " & dummy & "\n")
		input_file = dummy
		setText(INPUTtext, input_file)
		setText(OUTPUTtext, input_file[1..length(input_file)-5] & ".scad")
	end if
end procedure

procedure onClick_BrotINPUT()
--	Load_rot_file()
	sequence dummy
	dummy = Open_rot("")
	puts(1,"\nrot_file = " & dummy & "\n")
	if not equal(dummy, "") then
		rot_file = dummy
		setText(rotINPUTtext, dummy)
	end if
end procedure

procedure onClick_BRotFile()
	if isChecked(BRotFile) then
		setText(BRotFile, "RotFile On")
		setWindowBackColor(theWin, rgb(194+27,164+24,228-20))
	else
		setText(BRotFile, "RotFile Off")
		setWindowBackColor(theWin, rgb(194,164,228))
	end if
end procedure

procedure onClick_MAbout()
	atom result
	result = message_box(
fileName & " is a program that converts a \"*.shuf\" object descriptor\n"&
"into an OpenSCAD \"*.scad\" file.\n"&
"\n"&
"======== Copyright (C) 2020 Claudio Emiliozzi, Italy ========\n"&
"\n"&
"This program (and correlated file formats) is free software: you can \n"&
"      redistribute it and/or modify it under the terms of the\n"&
"GNU General Public License as published by theFree Software Foundation,\n"&
" either version 3 of the License, or (at your option) any later version.\n"&
"This program is distributed in the hope that it will be useful,\n"&
"but WITHOUT ANY WARRANTY; without even the implied warranty of \n"&
"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"&
"See the GNU General Public License for more details. You should have\n"&
" received a copy of the GNU General Public License along with this program.\n"&
"If not, see <https://www.gnu.org/licenses/>.\n"&
"               ", "About", 0 )
end procedure


procedure onClick_MInfo_()
	atom result
	result = message_box(
"      " & fileName & " is a program that converts a \"*.shuf\" object descriptor\n"&
"      into an OpenSCAD \"*.scad\" file.\n"&
"\n"&
"       ======== Copyright (C) 2020 Claudio Emiliozzi, Italy ========\n"&
"\n"&
"      Definitions and use:\n"&
"\n"&
"      SLICE: the representation of an object by OpenSHuFFle file is\n"&
"      like breaking it by n slices, then choosing some points on the\n"&
"      contour of every section.\n"&
"\n"&
"      SHELL: it's an OpenSCAD polyhedron. It's not really \"empty\":\n"&
"      nevertheless, boolean operations applied on it may show limitations.\n"&
"\n"&
"      HULL: convex OScad polyhedron, that become a regular OScad solid\n"&
"      by the application of the hull() function.\n"&
"\n"&
"      SHUFFLE FILE: a file that simply describes a Shell (and/or Hull),\n"&
"      by lists of points that forms the contour of sections of the object.\n"&
"\n"&
"      SUPPORT ARRAY: to 3d-print an object, you need a support, usually\n"&
"      generated by the slicer. By this function you can build your own\n"&
"      support, with less filament waste.\n"&
"\n"&
"      ROTFILE: a file that describes how the sections in shuffle file are bended,\n"&
"\n"&
"      rotated, swelled/shrinked and moved.\n"&
"\n"&
"      OpenSCAD is a free software Copyrighted (C) by \"The OpenSCAD Developers\"\n"&
"\n"&
"      Visit: www.RapidEuphoria.com for more informations on OpenEuphoria.\n"&
"\n"&
"      Thanks to Win32Lib v.0.45r developers.\n"&
"\n"&
"      Read Documentation.pdf for more informations\n"&
"               ", "Info", 0 )

end procedure

onClick[MAbout] = routine_id("onClick_MAbout")
onClick[MInfo_] = routine_id("onClick_MInfo_")

onClick[BMake_shell] = routine_id("onClick_BMake_shell")
onClick[BMake_solid] = routine_id("onClick_BMake_solid")
onClick[BSave] = routine_id("onClick_BSave_ABS_file")
--onClick[BPrSection] = routine_id("onClick_BPrSection")
onClick[BCreateSupportArray] = routine_id("onClick_BCreateSupportArray")
onClick[BINPUT] = routine_id("onClick_BINPUT")
onClick[BRotFile] = routine_id("onClick_BRotFile")
onClick[BrotINPUT] = routine_id("onClick_BrotINPUT")

--========================================================================

		 -- entrypoint
		 WinMain(theWin, Normal)

--CH==t==R==i==I==c==S==n==T==i==U==v==S===<<<>>>===s==V==u==I==t==N==s==C==i==I==r==T==hC------
----CH==t==R==a==I==n==S==g==T==e==U==r==S===<<<>>>===s==R==u==E==t==G==s==N==i==A==r==T==hC----
------CH==t==R==a==I==r==S==e==T==p==U==m==S==i<<<>>>I==s==M==u==P==t==E==s==R==i==A==r==T==hC--
